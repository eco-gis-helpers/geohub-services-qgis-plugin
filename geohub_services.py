# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OntarioGeohub
                                 A QGIS plugin
 A plugin to import layers from Ontario Geohub LIO
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by EcoGIS Helpers
        email                : aidan.w.obrien@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QDialog
from qgis.utils import iface
from qgis.core import (
    Qgis,
    QgsMessageLog,
    QgsProject,
    QgsVectorLayer,
    QgsFeature,
    QgsWkbTypes,
    QgsMapLayer,
    QgsProcessingFeatureSourceDefinition
    )
from qgis import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .geohub_services_dialog import OntarioGeohubDialog
import os.path
from .lio_list import lio_list

from .geohub_worker import (
    internet_on,
    get_service_crs,
    create_layer_group,
    canvas_bbox_for_service,
    rest_request,
    layer_bbox_for_service,
    layer_rest_request,
    clipping,
    WarningDialog,
    PolygonDialog,
    LayerSelectionDialog
)

from .geohub_worker import (
    treeRoot,
    counter,
    group_name
)


class OntarioGeohub:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OntarioGeohub_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Ontario Geohub Services')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('OntarioGeohub', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/geohub_services/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Query Ontario Geohub'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Ontario Geohub Services'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start:
            self.first_start = False

        service_crs = get_service_crs()
        pyqgis_group = create_layer_group(counter, group_name)

        # make the warning dialog string and pass it to the class above
        warn_str = (
            "Please note:\n\n"
            "- When querying by canvas, ensure you are sufficiently zoomed in to avoid performance issues \n"
            "- When querying by selected layer \,  avoid using an excessive number of features or very large polygons \n\n"
            "Otherwise \, QGIS may become unresponsive or crash."
        )

        warn_dialog = WarningDialog(warn_str)

        # pass the lio list to the layer selection dialog class made above
        dialog = LayerSelectionDialog(lio_list)

        if internet_on():
            if warn_dialog.exec_() == QDialog.Accepted:
                QgsMessageLog.logMessage("Zoom warning accepted. Selecting layers of interest", "Geohub-Services", level=Qgis.Info)
                print("Zoom warning accepted. Selecting layers of interest")
                if dialog.exec_() == QDialog.Accepted:
                    selected_layers = dialog.selected_layers()
                    
                    # make a list to hold the temporary layers
                    temp_layers = []
                    if dialog.get_bbox_function() == "layer_bbox_for_service":
                        QgsMessageLog.logMessage("Querying by selected layer", "Geohub-Services", level=Qgis.Info)
                        print("Querying by selected layer")

                        polygon_dialog = PolygonDialog()

                        if polygon_dialog.exec_() == QDialog.Accepted:
                            selected_polygon_layer, layer_name = polygon_dialog.get_selected_layer()
                            QgsMessageLog.logMessage(f"User selected polygon layer: {layer_name}", "Geohub-Services", level=Qgis.Info)
                            print(f"User selected polygon layer: {layer_name}")

                            # if no selected layer, raise a value error and notify the user
                            if not selected_polygon_layer:
                                treeRoot.removeChildNode(pyqgis_group)
                                iface.messageBar().pushMessage("Error", "No layer selected!", level=Qgis.Critical)
                                QgsMessageLog.logMessage("No layer selected!", "Geohub-Services", level=Qgis.Critical)
                                print("No layer selected!")
                                return

                            # If the selected layer is a raster, throw an error
                            # this shouldnt ever be possible with the new layer selection filter, but just in case
                            elif selected_polygon_layer.type() == QgsMapLayer.RasterLayer:
                                treeRoot.removeChildNode(pyqgis_group)
                                iface.messageBar().pushMessage("Error", "Selected layer is a raster!", level=Qgis.Critical)
                                QgsMessageLog.logMessage("The selected layer is a raster!", "Geohub-Services", level=Qgis.Critical)
                                print("The selected layer is a raster!")
                                return

                            # If the selected layer is a multi-polygon or polygon, keep going!
                            elif QgsWkbTypes.displayString(selected_polygon_layer.wkbType()) in ["MultiPolygon", "Polygon"]:
                                pass

                            # If the selected layer is not a Polygon or MultiPolygon, throw an error
                            # again, this shouldnt even be possible with the new layer selection filter, but just in case
                            else:
                                treeRoot.removeChildNode(pyqgis_group)
                                iface.messageBar().pushMessage("Error", "Selected layer is not a polygon!", level=Qgis.Critical)
                                QgsMessageLog.logMessage("The selected layer needs to be a polygon!", "Geohub-Services", level=Qgis.Critical)
                                print("The selected layer needs to be a polygon!")
                                return
                                
                            # get a list of the bboxes for each of the selected layers geometries
                            bbox_list = layer_bbox_for_service(service_crs, selected_polygon_layer)

                            layer_id_list = []
                            overlay_layer_list = []

                            for feature in selected_polygon_layer.getFeatures():
                                layer_id = feature.id()
                                layer_id_list.append(layer_id)
                                geometry = feature.geometry()

                                # make temp layers of each feature in the active layer for the clipping function
                                temp_layer_name = f"temp_clip_{layer_id}"
                                # load the temp layers in memory
                                temp_layer = QgsVectorLayer("Polygon?crs=" + selected_polygon_layer.crs().authid(), temp_layer_name, "memory")
                                temp_layer_provider = temp_layer.dataProvider()

                                # # Add the feature geometry to the temporary layer
                                temp_feature = QgsFeature()
                                temp_feature.setGeometry(geometry)
                                temp_layer_provider.addFeature(temp_feature)
                                temp_layer.updateExtents()

                                # Add the temporary layer to the project (for visibility in processing)
                                # TODO - do we need to show these temporary layers in the layers pane?
                                QgsProject.instance().addMapLayer(temp_layer)
                                temp_layers.append(temp_layer)
                                # Now that the layer is in the project, use it in the processing tool as the overlay for clipping
                                overlay_source = QgsProcessingFeatureSourceDefinition(temp_layer.id(), selectedFeaturesOnly=False)

                                overlay_layer_list.append(overlay_source)

                            # query the API using the bboxes from each geometry
                            loaded_layer_list, invalid_flag = layer_rest_request(bbox_list, selected_layers, service_crs, pyqgis_group)

                            if loaded_layer_list is None and invalid_flag is None:
                                QgsMessageLog.logMessage("Script was cancelled", "Geohub-Services", level=Qgis.Info)
                                print("Script was cancelled by user.")
                                # Clean up temp layers even if cancelled
                                for temp_layer in temp_layers:
                                    QgsProject.instance().removeMapLayer(temp_layer)
                                return
                                
                            clipping(loaded_layer_list, overlay_layer_list, layer_id_list, invalid_flag, pyqgis_group)

                            # Remove the temporary layers after processing
                            for temp_layer in temp_layers:
                                QgsProject.instance().removeMapLayer(temp_layer)

                        else:
                            treeRoot.removeChildNode(pyqgis_group)
                            QgsMessageLog.logMessage("Cancelled polygon selection", "Geohub-Services", level=Qgis.Info)
                            print("User cancelled polygon selection")
                            return

                    # otherwise the user selected the canvas bbox for query
                    elif dialog.get_bbox_function() == "canvas_bbox_for_service":
                        QgsMessageLog.logMessage("Querying by Canvas", "Geohub-Services", level=Qgis.Info)
                        print("Querying by Canvas")
                        # get the canvas bbox and query the api
                        str_bbox = canvas_bbox_for_service(service_crs)
                        rest_request(selected_layers, str_bbox, service_crs, pyqgis_group)

                else:
                    treeRoot.removeChildNode(pyqgis_group)
                    QgsMessageLog.logMessage("Script cancelled", "Geohub-Services", level=Qgis.Info)
                    print("User clicked Cancel. Stopping script.")
            else:
                treeRoot.removeChildNode(pyqgis_group)
                QgsMessageLog.logMessage("Script cancelled", "Geohub-Services", level=Qgis.Info)
                print("User clicked Cancel. Stopping script.")
        else:
            treeRoot.removeChildNode(pyqgis_group)
            iface.messageBar().pushMessage("Error", "Cannot establish connection to the network", level=Qgis.Critical)
            QgsMessageLog.logMessage("Cannot establish connection to the network", "Geohub-Services", level=Qgis.Critical)
            print("Cannot establish connection to the network. Please check your internet and try again.")